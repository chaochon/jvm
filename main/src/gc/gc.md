垃圾收集算法与垃圾收集器
==

# 1.概念

虚拟机的垃圾收集处理主要包括两个方面，一是判断哪些对象的内存需要回收，二是内存的收集和分配的策略

# 2.引用计数法与可达性分析算法
## 2.1 引用计数法

简单来说，就是堆中的每一个对象都维护一个引用计数变量，每当有一个变量引用它时，引用计数就加一，
一个变量不在引用它时，引用计数就减一。当引用计数为0时，就应当删除掉该对象内存。

## 2.2 可达性分析算法

基本思路是从一系列“GCRoots”的根对象作为起始节点集，根据引用关系向下搜索，如果在搜索完毕后，不可达
的对象就是被判定为需要回收的对象。

GC Roots对象主要包括
- 虚拟机栈中引用的对象
- 本地方法栈中JNI引用的对象
- 方法区中静态属性引用的对象、常量引用的对象
- java虚拟机中内部引用的对象
- 被同步锁持有的对象

## 2.2 引用分类

- 强引用：一般常用的引用的概念
- 软引用：用来描述一些有用，不是必要的对象。在系统内存快要溢出的时候，系统会将这些对象列入自动
回收的列表中，进行内存的二次回收
- 弱引用：用来描述一些有用，但不是必要的对象。强度更低一些，在系统下一次的内存回收时，会被释放掉
- 虚引用：唯一的目的是，被关联的对象在被自动回收时会向系统发送一个系统通知。

# 3.垃圾收集算法
## 3.1 标记-清除算法

算法基本思路：分成两步走，一、首先标记需要回收的内存，二、清除被标记的内存

缺点有两个：一、执行效率低，堆内存中大量的对象是需要回收的，就需要频发的标记、擦除对象操作。
二、内存空间碎片化，当出现需要连续大内存的对象时，需要出发另一次垃圾收集。

## 3.2 标记-整理算法

基本思路：在标记-清除算法的基础上，针对内存空间碎片化的问题，在清除之后，增加了整理操作，将存活下来的
内存移动至边界，在将之后的内存擦除。

上述两种方法的优缺点的比较：标记-清除算法由于没有移动操作，在垃圾回收时，速度更快，收集时间跟短
标记-整理算法相反，垃圾回收时，速度更慢，时间更长，但是在内存的读写更快。

## 3.3 标记-复制算法

基本思路：是一种半区复制算法。将内存分成两半，只用其中的一半作为可用内存，当半区的内存使用完时，
就将半区内存中存活的内存，按照顺序复制到另一个半区，并擦除本半区内存。


# 4. 经典垃圾收集器
## 4.1 